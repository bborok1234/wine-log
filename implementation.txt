Wine Log (V1) — implementation.txt (Supabase Auth + RLS)

목표
- 모바일 퍼스트 웹앱으로 “집 와인 셀러”를 2명 이상이 함께 관리
- 핵심: 재고(Stock) + 구매기록(Purchase) + 빠른 검색 + 평균 구매가(Avg)
- 로그인 기반 공유: Supabase Auth + House 멤버십 + RLS
- V1에서는 “오픈 이벤트 기록”은 생략(재고 -1만)

------------------------------
1) 스택(권장)
------------------------------
프론트
- Next.js (App Router) + TypeScript
- Tailwind CSS + Shadcn UI(Radix UI)
- URL 상태: nuqs (검색어/선택값을 searchParams로 관리)

백엔드(“Supabase가 백엔드”)
- Supabase Postgres
- Supabase Auth (V1: Email/Password)
- 사진 V1: URL 저장만(업로드는 V2에서 Supabase Storage로)

Supabase 최신 권장 패턴(Next.js)
- @supabase/supabase-js + @supabase/ssr
- 브라우저/서버용 Supabase client를 분리해서 생성
- 미들웨어(Proxy)로 세션 토큰 자동 갱신(SSR/RSC에서 쿠키를 직접 갱신할 수 없기 때문)
- 서버 보호 로직은 getSession 대신 getClaims를 사용(토큰 검증을 매번 수행)

참고 문서
- https://supabase.com/docs/guides/auth/server-side/creating-a-client?queryGroups=framework&framework=nextjs

------------------------------
2) 인증/공유(2명 이상) 모델
------------------------------
인증
- Supabase Auth로 로그인(Email/Password)
- 로그인 후에만 “House(셀러)” 데이터 접근 가능

공유
- House(셀러) 단위로 멤버십을 관리한다.
- 역할(role)
  - owner: 멤버/초대 관리 + 모든 변경
  - editor: 구매 추가/오픈/노트 수정
  - viewer: 읽기 전용

초대 링크(가족 공유 UX)
- owner가 “초대 링크 생성”을 누르면 house_invites에 랜덤 토큰을 만들고 role을 부여
- 초대받은 사람은 /invite/<token>으로 접속 → 로그인 → “수락” 버튼 → 멤버로 등록
- 구현은 RPC(accept_invite)를 1개 두는 방식을 권장
  - 토큰을 안전하게 처리(만료/중복/재사용)하고
  - house_members 삽입 RLS를 단순화(“오너만 insert” 같은 정책 유지 가능)

------------------------------
3) 데이터 모델(DB 스키마)
------------------------------
핵심 규칙
- “같은 와인”의 ID: producer + name(cuvée) + vintage (house 내 유니크)

테이블(권장 최소)

houses
- id (uuid, pk)
- name (text, optional)
- created_by (uuid, references auth.users)
- created_at (timestamptz)

house_members
- house_id (uuid, fk -> houses.id)
- user_id (uuid, references auth.users)
- role (text, check in ('owner','editor','viewer'))
- created_at (timestamptz)
- primary key (house_id, user_id)

house_invites
- id (uuid, pk)
- house_id (uuid, fk -> houses.id)
- token (text, unique)               // 충분히 긴 랜덤 문자열
- role (text, check in ('editor','viewer'))
- expires_at (timestamptz, optional)
- created_by (uuid, references auth.users)
- used_by (uuid, references auth.users, optional)
- used_at (timestamptz, optional)
- created_at (timestamptz)

wines
- id (uuid, pk)
- house_id (uuid, fk -> houses.id)
- producer (text, required)
- name (text, required)              // cuvée/name
- vintage (int, required)
- country (text, optional)
- region (text, optional)
- type (text, optional)              // enum 대신 text

재고/가격(파생값 저장: 리스트 성능/단순화)
- stock_qty (int, required, default 0)
- purchase_qty_total (int, required, default 0)
- purchase_value_total (numeric, required, default 0)
- avg_purchase_price (numeric, required, default 0)

노트(V1 단순)
- rating (int, optional)             // 1~5
- comment (text, optional)
- tasting_review (text, optional)
- label_photo_urls (text[], optional)// URL 배열(업로드 X)

타임스탬프
- created_at (timestamptz)
- updated_at (timestamptz)

유니크 제약(중요)
- unique(house_id, producer, name, vintage)

purchases
- id (uuid, pk)
- house_id (uuid, fk -> houses.id)
- wine_id (uuid, fk -> wines.id)
- purchased_at (date, required, default today)
- store (text, required)
- unit_price (numeric, required)     // 병당 가격
- quantity (int, required)
- receipt_photo_url (text, optional)
- created_at (timestamptz)

인덱스(권장)
- wines: index(house_id)
- purchases: index(wine_id, purchased_at desc)

------------------------------
4) 정합성(가격/재고) 업데이트 규칙
------------------------------
Add Purchase (구매 추가)
- purchases insert
- wines 업데이트(원자적으로)
  - stock_qty += quantity
  - purchase_qty_total += quantity
  - purchase_value_total += unit_price * quantity
  - avg_purchase_price = purchase_value_total / purchase_qty_total

권장 구현
- purchases AFTER INSERT 트리거로 wines 파생값을 갱신
  - 클라이언트는 purchases만 insert하면 됨(UX/코드 단순)

Open Bottle (병 오픈)
- V1: wines.stock_qty = greatest(stock_qty - 1, 0)
- 구현 옵션
  - (단순) editor/owner에게 wines 업데이트 권한을 주고 클라이언트가 update
  - (안전) rpc_open_bottle(wine_id)로만 감소(필드 임의 변경 방지)

------------------------------
AI (Gemini) 기능
------------------------------
- ENV: OPENAI_API_KEY 필요 (모델: OPENAI_MODEL, 기본 gpt-4o-mini)
- 공용 유틸: web/src/lib/ai/openai.ts (OpenAI Chat Completions + JSON 추출)
- API 라우트
  - POST /api/ai/parse-wine      : 자유 텍스트 → 와인 정보 추출(JSON)
  - POST /api/ai/analyze-label   : 라벨 이미지(base64) → 와인 정보 추출(JSON)
  - POST /api/ai/recommend       : 보유 재고 중 오늘 마실 와인 추천(JSON: wineId, reason, pairing)
  - POST /api/ai/sommelier       : 특정 와인에 대한 AI 소믈리에 조언(JSON: description, pairing, servingTemp, grapeVariety)
- UI 연동
  - Cellar: AI 추천 FAB/모달 → /api/ai/recommend
  - Wine Detail: AI 소믈리에 카드 → /api/ai/sommelier
  - Add Purchase (create step): 사진/텍스트 AI 분석 → /api/ai/analyze-label, /api/ai/parse-wine로 필드 자동 채움

------------------------------
5) RLS 정책(핵심)
------------------------------
원칙
- 모든 테이블 RLS 활성화
- 데이터 접근은 “현재 사용자(auth.uid())가 해당 house의 멤버인지”로 결정
- 쓰기 권한은 role in ('owner','editor')로 제한

권장 헬퍼(개념)
- is_house_member(house_id): house_members에 auth.uid 존재 여부
- can_write_house(house_id): role이 owner/editor인지

정책 의도(요약)
- houses
  - select: is_house_member(id)
  - insert: authenticated 사용자만(생성 후 owner 멤버십을 추가하는 트리거/액션 필요)
- house_members
  - select: is_house_member(house_id)
  - insert/update/delete: owner만(또는 RPC로만)
- wines
  - select: is_house_member(house_id)
  - insert/update/delete: can_write_house(house_id)
- purchases
  - select: is_house_member(house_id)
  - insert: can_write_house(house_id)

초대 수락
- 권장: rpc_accept_invite(invite_token) SECURITY DEFINER
  - invite_token 유효/만료/사용 여부 확인
  - house_members에 (house_id, auth.uid, role) 삽입(중복이면 noop)
  - invite used_by/used_at 갱신(재사용 정책은 선택)

------------------------------
6) Next.js 구현 방식(최신 권장)
------------------------------
환경변수
- NEXT_PUBLIC_SUPABASE_URL
- NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY (권장: Connect에서 제공)
  - 전환기에는 legacy anon key도 사용 가능하지만, 문서 권장 키를 우선

클라이언트 유틸(예: src/lib/supabase/*)
- client.ts: createBrowserClient(...)
- server.ts: createServerClient(..., { cookies })
- middleware: updateSession(request)로 쿠키/세션 자동 갱신

데이터 접근
- 조회: RSC(Server Components)에서 server client로 직접 조회(최소 use client)
- 변경: 우선 Server Actions(폼)로 처리하거나, 필요 시 Client Component에서 browser client 사용
  - 어떤 방식이든 “service_role”은 쓰지 않고, 사용자 세션 + RLS로 보호

------------------------------
7) 화면/라우트(UI)
------------------------------
Auth
- /login: Email/Password (Sign in / Sign up)

App(예시 라우팅)
- /app: 내 house 목록(또는 최근 house로 이동)
- /h/<houseId>/cellar
- /h/<houseId>/search?q=
- /h/<houseId>/wine/<wineId>
- /h/<houseId>/purchase/new?wineId=
- /invite/<token>: 초대 수락 → 해당 house로 이동

Cellar List (Main)
- 와인명, producer/region(작게), avg purchase price, stock
- 액션: 상세 이동, 오픈(stock -1), 구매 추가
- 검색 진입은 최상단(아이콘/입력)

Search
- 단일 입력, 즉시 결과(검색어는 nuqs로 q 관리)
- 검색 대상: name, producer, region, country
- 결과 없음: “새 와인 + 구매 추가” 플로우로 연결

Wine Detail
- Identity, Stock/Avg, Actions, Notes(별점/코멘트/리뷰/사진 URL), 구매 히스토리(접기/펼치기)

Add Purchase
- 기존 와인 선택(검색) 또는 새 와인 생성
- 필수: price, qty, store, date(기본 오늘)
- 저장: purchases insert → 트리거로 stock/avg 갱신 → 목록으로 이동

------------------------------
8) 구현 순서(체크리스트)
------------------------------
1) Next.js 스캐폴딩 + Tailwind/Shadcn + nuqs
2) Supabase Auth(Email/Password) 설정 + Next.js SSR client/middleware 구성(@supabase/ssr)
3) DB 스키마 생성 + RLS 정책 적용 + purchases 트리거 + invite RPC
4) House 생성/선택 UI + 초대 링크 생성/수락 UI
5) Cellar List
6) Search
7) Wine Detail
8) Add Purchase
9) Open bottle
10) (옵션) Export JSON/CSV

------------------------------
9) 가드레일/엣지 케이스
------------------------------
- stock_qty 0일 때 오픈 비활성화
- avg 계산: purchase_qty_total == 0이면 0 표시
- 동일 와인 중복 생성 방지(유니크 위반) → UX로 기존 와인 유도
- 숫자 입력 검증(가격/수량/빈티지) + 빈 값 가드
- viewer는 변경 UI를 숨김/disabled

------------------------------
10) V2 후보(나중에)
------------------------------
- Supabase Storage 업로드(라벨/영수증) + 썸네일
- Open 이벤트 테이블(오픈 이력)
- pg_trgm 인덱스 + 검색 고도화
- 다중 house/가족 단위 권한 UX 개선(초대 재발급/만료/감사 로그 등)

